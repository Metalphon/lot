<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>国际跳棋</title>
    <style>
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .game-info {
            display: flex;
            gap: 20px;
            align-items: center;
            margin: 20px 0;
        }
        .board {
            display: grid;
            grid-template-columns: repeat(10, 60px);
            grid-template-rows: repeat(10, 60px);
            gap: 0;
            margin-bottom: 20px;
            border: 15px solid #DAA520;
            box-shadow: 
                0 0 15px rgba(0, 0, 0, 0.2),
                inset 0 0 8px rgba(0, 0, 0, 0.3);
            background: #DAA520;
            padding: 3px;
            border-radius: 3px;
        }
        .black, .white {
            width: 60px;
            height: 60px;
            cursor: pointer;
        }
        .black {
            background-color: #2c2c2c;
        }
        .white {
            background-color: #f0f0f0;
        }
        .piece {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            margin: 5px;
            cursor: pointer;
            position: relative;
            transition: transform 0.2s;
        }
        .black-piece {
            background: radial-gradient(circle at 30% 30%, #666, #000);
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.4),
                inset 0 2px 4px rgba(255, 255, 255, 0.3);
        }
        .white-piece {
            background: radial-gradient(circle at 30% 30%, #fff, #ccc);
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.4),
                inset 0 2px 4px rgba(255, 255, 255, 0.8);
        }
        .piece:hover {
            transform: scale(1.05);
        }
        .king {
            border: 3px solid gold;
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.4),
                inset 0 2px 4px rgba(255, 255, 255, 0.3),
                0 0 10px gold;
        }
        .highlight {
            background-color: #32CD32 !important;
            box-shadow: inset 0 0 15px rgba(255, 255, 255, 0.4);
        }
        .current-player {
            padding: 12px 24px;
            border: 2px solid #333;
            width: 120px;
            text-align: center;
            border-radius: 5px;
            background: #fff;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            cursor: pointer;
        }
        .current-player:hover {
            background: #f5f5f5;
        }
        .restart-button, .edit-mode-button {
            padding: 12px 24px;
            font-size: 16px;
            background: linear-gradient(145deg, #2c2c2c, #1a1a1a);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        .restart-button:hover, .edit-mode-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .edit-mode-button.active {
            background: linear-gradient(145deg, #4CAF50, #45a049);
        }
        
        .edit-options {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            display: none;
            z-index: 1000;
        }
        
        .edit-options button {
            display: block;
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            border: none;
            border-radius: 4px;
            background: #4CAF50;
            color: white;
            cursor: pointer;
        }
        
        .edit-options button:hover {
            background: #45a049;
        }

        .clear-board-button {
            padding: 12px 24px;
            font-size: 16px;
            background: linear-gradient(145deg, #ff4444, #cc0000);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            margin-left: 10px;
        }
        
        .clear-board-button:hover {
            background: linear-gradient(145deg, #cc0000, #ff4444);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .capture-hint {
            padding: 10px 15px;
            margin-left: 15px;
            background-color: #fff3cd;
            border: 1px solid #ffeeba;
            border-radius: 5px;
            color: #856404;
            min-width: 200px;
            display: none;
        }
        
        .capture-hint.show {
            display: block;
            animation: fadeIn 0.3s ease-in-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>国际跳棋</h1>
        <div class="game-info">
            <div class="current-player" id="currentPlayer" onclick="toggleTurn()">白方回合</div>
            <button class="restart-button" onclick="restartGame()">重新开始</button>
            <button class="edit-mode-button" onclick="toggleEditMode()">普通模式</button>
            <button class="clear-board-button" onclick="clearBoard()">清除棋子</button>
            <div class="capture-hint" id="captureHint"></div>
        </div>
        <div class="board" id="board"></div>
        
        <!-- 添加编辑选项对话框 -->
        <div id="editOptions" class="edit-options">
            <button onclick="setSquareProperty(selectedRow, selectedCol, '空格')">空格</button>
            <button onclick="setSquareProperty(selectedRow, selectedCol, '黑棋')">黑棋</button>
            <button onclick="setSquareProperty(selectedRow, selectedCol, '黑王')">黑王</button>
            <button onclick="setSquareProperty(selectedRow, selectedCol, '白棋')">白棋</button>
            <button onclick="setSquareProperty(selectedRow, selectedCol, '白王')">白王</button>
            <button onclick="hideEditOptions()">取消</button>
        </div>
    </div>

    <script>
        const boardElement = document.getElementById('board');
        const currentPlayerElement = document.getElementById('currentPlayer');
        const board = [];
        let selectedPiece = null;
        let currentPlayer = 'white-piece';
        let editMode = false;
        let selectedRow, selectedCol;
        const editOptionsElement = document.getElementById('editOptions');

        function createBoard() {
            for (let row = 0; row < 10; row++) {
                board[row] = [];
                for (let col = 0; col < 10; col++) {
                    const square = document.createElement('div');
                    square.className = (row + col) % 2 === 0 ? 'black' : 'white';
                    square.dataset.row = row;
                    square.dataset.col = col;
                    square.addEventListener('click', () => selectSquare(row, col));
                    boardElement.appendChild(square);
                    board[row][col] = null;

                    if (square.className === 'black') {
                        if (row < 4) {
                            const piece = createPiece('black-piece');
                            square.appendChild(piece);
                            board[row][col] = piece;
                        } else if (row > 5) {
                            const piece = createPiece('white-piece');
                            square.appendChild(piece);
                            board[row][col] = piece;
                        }
                    }
                }
            }
            console.log("Board created");
        }

        function createPiece(color) {
            const piece = document.createElement('div');
            piece.className = `piece ${color}`;
            return piece;
        }

        function selectSquare(row, col) {
            if (editMode) {
                showEditOptions(row, col);
            } else {
                // 检查光标位置是否可以连续吃子
                if (board[row][col] === null) {
                    // 创建一个虚拟棋子用于检查
                    const virtualPiece = {
                        classList: {
                            contains: (className) => className === currentPlayer
                        }
                    };
                    
                    // 临时将虚拟棋子放置在光标位置
                    board[row][col] = virtualPiece;
                    
                    // 检查是否可以吃子
                    const capturePaths = findAllCapturePaths(row, col, virtualPiece);
                    
                    // 移除虚拟棋子
                    board[row][col] = null;
                    
                    // 只有当有多步连吃时才显示
                    if (capturePaths.length > 0 && capturePaths.some(path => path.length > 1)) {
                        // 找出最长的连吃路径
                        const longestPath = capturePaths.reduce((longest, current) => 
                            current.length > longest.length ? current : longest
                        , []);
                        
                        // 显示最终位置
                        clearHighlights();
                        const finalMove = longestPath[longestPath.length - 1];
                        const [finalRow, finalCol] = finalMove.targetPos;
                        const finalSquare = document.querySelector(`[data-row='${finalRow}'][data-col='${finalCol}']`);
                        finalSquare.classList.add('highlight');
                        
                        // 显示连吃提示
                        const hintElement = document.getElementById('captureHint');
                        const pieceType = currentPlayer === 'white-piece' ? '白棋' : '黑棋';
                        hintElement.textContent = `光标位置可以连续吃${longestPath.length}个子！`;
                        hintElement.classList.add('show');
                        setTimeout(() => {
                            hintElement.classList.remove('show');
                        }, 3000);
                        
                        return;
                    }
                }
                
            clearHighlights();
            if (selectedPiece) {
                console.log(`Attempting to move piece from (${selectedPiece.row}, ${selectedPiece.col}) to (${row}, ${col})`);
                movePiece(row, col);
            } else if (board[row][col] && board[row][col].classList.contains(currentPlayer)) {
                if (mustCapture() && !canCapture(row, col)) {
                    console.log(`Must capture, cannot select piece at (${row}, ${col})`);
                    return;
                }
                selectedPiece = { piece: board[row][col], row, col };
                highlightMoves(row, col);
                console.log(`Selected piece at (${row}, ${col})`);
            } else {
                console.log(`Invalid selection at (${row}, ${col})`);
            }
            }
        }

        function showEditOptions(row, col) {
            selectedRow = row;
            selectedCol = col;
            editOptionsElement.style.display = 'block';
        }

        function hideEditOptions() {
            editOptionsElement.style.display = 'none';
        }

        function setCurrentPlayer(player) {
            currentPlayer = player;
            updateCurrentPlayerText();
            hideEditOptions();
        }

        function setSquareProperty(row, col, property) {
            const square = document.querySelector(`[data-row='${row}'][data-col='${col}']`);
            square.innerHTML = '';
            board[row][col] = null;

            switch (property) {
                case '白棋':
                    const whitePiece = createPiece('white-piece');
                    square.appendChild(whitePiece);
                    board[row][col] = whitePiece;
                    break;
                case '黑棋':
                    const blackPiece = createPiece('black-piece');
                    square.appendChild(blackPiece);
                    board[row][col] = blackPiece;
                    break;
                case '白王':
                    const whiteKing = createPiece('white-piece');
                    whiteKing.classList.add('king');
                    square.appendChild(whiteKing);
                    board[row][col] = whiteKing;
                    break;
                case '黑王':
                    const blackKing = createPiece('black-piece');
                    blackKing.classList.add('king');
                    square.appendChild(blackKing);
                    board[row][col] = blackKing;
                    break;
                case '空格':
                default:
                    break;
            }
            hideEditOptions();
        }

        function toggleEditMode() {
            editMode = !editMode;
            const editButton = document.querySelector('.edit-mode-button');
            
            if (editMode) {
                editButton.classList.add('active');
                editButton.textContent = '编辑模式';
                editButton.style.background = 'linear-gradient(145deg, #4CAF50, #45a049)';
            } else {
                editButton.classList.remove('active');
                editButton.textContent = '普通模式';
                editButton.style.background = 'linear-gradient(145deg, #2c2c2c, #1a1a1a)';
            }
            
            // 清除选中状态和高亮
            selectedPiece = null;
            clearHighlights();
            hideEditOptions();
        }

        function movePiece(row, col) {
            const { piece, row: oldRow, col: oldCol } = selectedPiece;

            if (isValidMove(oldRow, oldCol, row, col)) {
                // 检查是否是吃子移动
                const rowDiff = row - oldRow;
                const colDiff = col - oldCol;
                const isCapture = piece.classList.contains('king') ? 
                    Math.abs(rowDiff) >= 2 && Math.abs(colDiff) >= 2 : // 王棋的吃子判断
                    Math.abs(rowDiff) === 2 && Math.abs(colDiff) === 2; // 普通棋子的吃子判断

                // 如果是吃子移动，检查是否可以继续吃子
                if (isCapture) {
                    // 获取所有可能的连续吃子路径
                    const capturePaths = findAllCapturePaths(row, col, piece);
                    if (capturePaths.length > 0) {
                        // 执行最长的吃子路径
                        const longestPath = capturePaths.reduce((longest, current) => 
                            current.length > longest.length ? current : longest
                        );
                        
                        // 先移动到第一个吃子位置
                        board[oldRow][oldCol] = null;
                        board[row][col] = piece;
                        const square = document.querySelector(`[data-row='${row}'][data-col='${col}']`);
                        square.appendChild(piece);
                        
                        // 更新selectedPiece到当前位置
                        selectedPiece = { piece, row, col };
                        
                        // 执行连续吃子
                        executeCapturePath(row, col, piece, longestPath);
                        return;
                    }
                }
                
                // 普通移动或单次吃子
                board[oldRow][oldCol] = null;
                board[row][col] = piece;
                const square = document.querySelector(`[data-row='${row}'][data-col='${col}']`);
                square.appendChild(piece);

                // 更新selectedPiece到新位置
                selectedPiece = { piece, row, col };

                // Check for king promotion
                if ((currentPlayer === 'white-piece' && row === 0) || (currentPlayer === 'black-piece' && row === 9)) {
                    piece.classList.add('king');
                }

                if (isCapture) {
                    // 单次吃子，检查是否有后续吃子机会
                    if (canCapture(row, col)) {
                    highlightMoves(row, col);
                    } else {
                        selectedPiece = null;
                        currentPlayer = currentPlayer === 'white-piece' ? 'black-piece' : 'white-piece';
                        updateCurrentPlayerText();
                    }
                } else {
                    // 普通移动，直接切换玩家
                    selectedPiece = null;
                    currentPlayer = currentPlayer === 'white-piece' ? 'black-piece' : 'white-piece';
                    updateCurrentPlayerText();
                }
            } else {
                console.log(`Invalid move from (${oldRow}, ${oldCol}) to (${row}, ${col})`);
                selectedPiece = null;
            }
        }

        // 查找所有可能的连续吃子路径
        function findAllCapturePaths(startRow, startCol, piece, path = [], paths = []) {
            const currentPath = [...path];
            
            // 模拟当前位置的所有可能吃子
            const possibleCaptures = [];
            const directions = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
            
            if (piece.classList.contains('king')) {
                // 王棋的吃子检查
                for (const [dRow, dCol] of directions) {
                    let checkRow = startRow + dRow;
                    let checkCol = startCol + dCol;
                    let foundOpponent = false;
                    let opponentPos = null;
                    
                    while (checkRow >= 0 && checkRow < 10 && checkCol >= 0 && checkCol < 10) {
                        if (board[checkRow][checkCol] !== null) {
                            if (board[checkRow][checkCol].classList.contains(currentPlayer)) break;
                            if (foundOpponent) break;
                            foundOpponent = true;
                            opponentPos = [checkRow, checkCol];
                            
                            // 继续检查对手棋子后的空位
                            let nextRow = checkRow + dRow;
                            let nextCol = checkCol + dCol;
                            while (nextRow >= 0 && nextRow < 10 && nextCol >= 0 && nextCol < 10) {
                                if (board[nextRow][nextCol] !== null) break;
                                possibleCaptures.push({
                                    targetPos: [nextRow, nextCol],
                                    capturePos: opponentPos
                                });
                                nextRow += dRow;
                                nextCol += dCol;
                            }
                            break;
                        }
                        checkRow += dRow;
                        checkCol += dCol;
                    }
                }
            } else {
                // 普通棋子的吃子检查
                for (const [dRow, dCol] of directions) {
                    const newRow = startRow + 2 * dRow;
                    const newCol = startCol + 2 * dCol;
                    const middleRow = startRow + dRow;
                    const middleCol = startCol + dCol;
                    
                    if (newRow >= 0 && newRow < 10 && newCol >= 0 && newCol < 10 && 
                        board[middleRow][middleCol] && 
                        !board[middleRow][middleCol].classList.contains(currentPlayer) && 
                        board[newRow][newCol] === null) {
                        possibleCaptures.push({
                            targetPos: [newRow, newCol],
                            capturePos: [middleRow, middleCol]
                        });
                    }
                }
            }
            
            if (possibleCaptures.length === 0) {
                if (currentPath.length > 0) {
                    paths.push(currentPath);
                }
                return paths;
            }
            
            // 对每个可能的吃子位置进行递归
            for (const capture of possibleCaptures) {
                const [targetRow, targetCol] = capture.targetPos;
                const [captureRow, captureCol] = capture.capturePos;
                
                // 保存当前状态
                const originalBoard = board.map(row => [...row]);
                
                // 模拟吃子
                board[captureRow][captureCol] = null;
                board[startRow][startCol] = null;
                board[targetRow][targetCol] = piece;
                
                // 递归查找后续吃子
                findAllCapturePaths(targetRow, targetCol, piece, 
                    [...currentPath, { targetPos: capture.targetPos, capturePos: capture.capturePos }], 
                    paths);
                
                // 恢复状态
                board.forEach((row, i) => {
                    board[i] = [...originalBoard[i]];
                });
            }
            
            return paths;
        }

        // 执行连续吃子路径
        function executeCapturePath(startRow, startCol, piece, path) {
            let currentRow = startRow;
            let currentCol = startCol;
            
            // 创建动画效果的延迟时间
            const delay = 2000; // 2秒
            
            // 清除所有高亮
            clearHighlights();
            
            // 直接显示最终位置的高亮
            const finalMove = path[path.length - 1];
            const [finalRow, finalCol] = finalMove.targetPos;
            const finalSquare = document.querySelector(`[data-row='${finalRow}'][data-col='${finalCol}']`);
            finalSquare.classList.add('highlight');
            
            // 立即更新selectedPiece到最终位置
            selectedPiece = { piece, row: finalRow, col: finalCol };
            
            path.forEach((move, index) => {
                setTimeout(() => {
                    const [targetRow, targetCol] = move.targetPos;
                    const [captureRow, captureCol] = move.capturePos;
                    
                    // 移除被吃的棋子
                    if (board[captureRow][captureCol]) {
                        board[captureRow][captureCol].remove();
                        board[captureRow][captureCol] = null;
                    }
                    
                    // 移动当前棋子
                    board[currentRow][currentCol] = null;
                    board[targetRow][targetCol] = piece;
                    const targetSquare = document.querySelector(`[data-row='${targetRow}'][data-col='${targetCol}']`);
                    targetSquare.appendChild(piece);
                    
                    currentRow = targetRow;
                    currentCol = targetCol;
                    
                    // 如果是最后一步
                    if (index === path.length - 1) {
                        // 检查是否需要升王
                        if ((currentPlayer === 'white-piece' && targetRow === 0) || 
                            (currentPlayer === 'black-piece' && targetRow === 9)) {
                            piece.classList.add('king');
                        }
                        
                        // 检查是否还能继续吃子
                        if (canCapture(currentRow, currentCol)) {
                            setTimeout(() => {
                                highlightMoves(currentRow, currentCol);
                            }, 100);
                        } else {
                            selectedPiece = null;
                            currentPlayer = currentPlayer === 'white-piece' ? 'black-piece' : 'white-piece';
                            updateCurrentPlayerText();
                            clearHighlights();
                        }
                    }
                }, index * delay);
            });
        }

        function isValidMove(oldRow, oldCol, newRow, newCol) {
            console.log(`Checking move from (${oldRow}, ${oldCol}) to (${newRow}, ${newCol})`);
            const rowDiff = newRow - oldRow;
            const colDiff = newCol - oldCol;

            if (board[newRow][newCol] !== null) {
                console.log('Target square is occupied');
                return false;
            }

            if (board[oldRow][oldCol].classList.contains('king')) {
                console.log('Moving a king piece');
                // 检查是否有吃子机会
                if (mustCapture()) {
                    // 在有吃子机会时，必须执行吃子移动
                    let foundOpponent = false;
                    const stepRow = rowDiff / Math.abs(rowDiff);
                    const stepCol = colDiff / Math.abs(colDiff);
                    
                    // 首先验证这个移动是否是有效的吃子移动
                    if (Math.abs(rowDiff) < 2 || Math.abs(colDiff) < 2) {
                        console.log('Must make a capture move when capture is available');
                        return false;
                    }
                    
                    // 检查路径上是否有且仅有一个对手的棋子
                    let opponentRow = -1;
                    let opponentCol = -1;
                    for (let i = 1; i < Math.abs(rowDiff); i++) {
                        const currentRow = oldRow + i * stepRow;
                        const currentCol = oldCol + i * stepCol;
                        if (board[currentRow][currentCol] !== null) {
                            if (foundOpponent || board[currentRow][currentCol].classList.contains(currentPlayer)) {
                                return false;
                            }
                            foundOpponent = true;
                            opponentRow = currentRow;
                            opponentCol = currentCol;
                        }
                    }
                    
                    // 必须是吃子移动
                    if (!foundOpponent) {
                        console.log('Must capture when possible');
                        return false;
                    }

                    // 验证这个移动是否是当前可能的吃子移动之一
                    const possibleCaptures = [];
                    const directions = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
                    for (const [dRow, dCol] of directions) {
                        let checkRow = oldRow + dRow;
                        let checkCol = oldCol + dCol;
                        let foundTarget = false;
                        
                        while (checkRow >= 0 && checkRow < 10 && checkCol >= 0 && checkCol < 10) {
                            if (board[checkRow][checkCol] !== null) {
                                if (board[checkRow][checkCol].classList.contains(currentPlayer)) break;
                                if (foundTarget) break;
                                foundTarget = true;
                                
                                // 继续检查对手棋子后的所有空位
                                let nextRow = checkRow + dRow;
                                let nextCol = checkCol + dCol;
                                while (nextRow >= 0 && nextRow < 10 && nextCol >= 0 && nextCol < 10) {
                                    if (board[nextRow][nextCol] !== null) break;
                                    possibleCaptures.push([nextRow, nextCol]);
                                    nextRow += dRow;
                                    nextCol += dCol;
                                }
                            }
                            checkRow += dRow;
                            checkCol += dCol;
                        }
                    }
                    
                    // 检查目标位置是否在可能的吃子移动列表中
                    const isValidCapture = possibleCaptures.some(([row, col]) => row === newRow && col === newCol);
                    if (!isValidCapture) {
                        console.log('Must make one of the available capture moves');
                        return false;
                    }

                    // 执行吃子移动
                    board[opponentRow][opponentCol].remove();
                    board[opponentRow][opponentCol] = null;
                    return true;
                } else {
                    // 没有吃子机会时的普通移动
                    if (Math.abs(rowDiff) === Math.abs(colDiff)) {
                        const stepRow = rowDiff / Math.abs(rowDiff);
                        const stepCol = colDiff / Math.abs(colDiff);
                        
                        // 检查路径上是否有棋子
                        for (let i = 1; i < Math.abs(rowDiff); i++) {
                            const currentRow = oldRow + i * stepRow;
                            const currentCol = oldCol + i * stepCol;
                            if (board[currentRow][currentCol] !== null) {
                                return false;
                            }
                        }
                        return true;
                    }
                }
            } else {
                // 普通棋子的移动逻辑保持不变
                const direction = currentPlayer === 'white-piece' ? -1 : 1;

                if (mustCapture()) {
                    // 在有吃子机会时，必须执行吃子移动
                    if (Math.abs(rowDiff) === 2 && Math.abs(colDiff) === 2) {
                    const middleRow = (oldRow + newRow) / 2;
                    const middleCol = (oldCol + newCol) / 2;
                        if (board[middleRow][middleCol] && 
                            !board[middleRow][middleCol].classList.contains(currentPlayer)) {
                        board[middleRow][middleCol].remove();
                        board[middleRow][middleCol] = null;
                            return true;
                        }
                    }
                    return false;
                } else {
                    // 没有吃子机会时的普通移动
                    if (rowDiff === direction && Math.abs(colDiff) === 1) {
                        return true;
                    }
                }
            }

            console.log('Move is invalid');
            return false;
        }

        function canCapture(row, col, isCheckingMultiple = false) {
            console.log(`Checking capture possibilities for piece at (${row}, ${col})`);
            const directions = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
            const piece = board[row][col];
            const capturePositions = [];
            
            if (piece.classList.contains('king')) {
            for (const [dRow, dCol] of directions) {
                let newRow = row + dRow;
                let newCol = col + dCol;
                let foundOpponent = false;
                    let opponentRow = -1;
                    let opponentCol = -1;
                    
                    while (newRow >= 0 && newRow < 10 && newCol >= 0 && newCol < 10) {
                    if (board[newRow][newCol] !== null) {
                        if (board[newRow][newCol].classList.contains(currentPlayer)) break;
                        if (foundOpponent) break;
                        foundOpponent = true;
                            opponentRow = newRow;
                            opponentCol = newCol;
                            
                            // 继续检查对手棋子后的空位
                            let checkRow = newRow + dRow;
                            let checkCol = newCol + dCol;
                            while (checkRow >= 0 && checkRow < 10 && checkCol >= 0 && checkCol < 10) {
                                if (board[checkRow][checkCol] !== null) break;
                                capturePositions.push([checkRow, checkCol]);
                                
                                if (!isCheckingMultiple) {
                                    // 临时保存当前状态
                                    const originalBoard = board.map(row => [...row]);
                                    
                                    // 模拟吃子移动
                                    board[opponentRow][opponentCol] = null;
                                    board[row][col] = null;
                                    board[checkRow][checkCol] = piece;
                                    
                                    // 检查是否可以继续吃子
                                    if (canCapture(checkRow, checkCol, true)) {
                                        const hintElement = document.getElementById('captureHint');
                                        const pieceType = piece.classList.contains('white-piece') ? '白棋' : '黑棋';
                                        const kingText = piece.classList.contains('king') ? '王' : '';
                                        hintElement.textContent = `${pieceType}${kingText}可以连续吃子！`;
                                        hintElement.classList.add('show');
                                        setTimeout(() => {
                                            hintElement.classList.remove('show');
                                        }, 3000);
                                    }
                                    
                                    // 恢复原始状态
                                    board.forEach((row, i) => {
                                        board[i] = [...originalBoard[i]];
                                    });
                                }
                                
                                checkRow += dRow;
                                checkCol += dCol;
                            }
                            break;
                    }
                    newRow += dRow;
                    newCol += dCol;
                }
            }
            } else {
                for (const [dRow, dCol] of directions) {
                    const newRow = row + 2 * dRow;
                    const newCol = col + 2 * dCol;
                    const middleRow = row + dRow;
                    const middleCol = col + dCol;
                    
                    if (newRow >= 0 && newRow < 10 && newCol >= 0 && newCol < 10 && 
                        board[middleRow][middleCol] && 
                        !board[middleRow][middleCol].classList.contains(currentPlayer) && 
                        board[newRow][newCol] === null) {
                        capturePositions.push([newRow, newCol]);
                        if (!isCheckingMultiple) {
                            // 临时保存当前状态
                            const originalBoard = board.map(row => [...row]);
                            const capturedPiece = board[middleRow][middleCol];
                            
                            // 模拟吃子移动
                            board[middleRow][middleCol] = null;
                            board[row][col] = null;
                            board[newRow][newCol] = piece;
                            
                            // 检查是否可以继续吃子
                            if (canCapture(newRow, newCol, true)) {
                                const hintElement = document.getElementById('captureHint');
                                const pieceType = piece.classList.contains('white-piece') ? '白棋' : '黑棋';
                                const kingText = piece.classList.contains('king') ? '王' : '';
                                hintElement.textContent = `${pieceType}${kingText}可以连续吃子！`;
                                hintElement.classList.add('show');
                                setTimeout(() => {
                                    hintElement.classList.remove('show');
                                }, 3000);
                            }
                            
                            // 恢复原始状态
                            board.forEach((row, i) => {
                                board[i] = [...originalBoard[i]];
                            });
                        }
                    }
                }
            }
            
            return capturePositions.length > 0;
        }

        function highlightMoves(row, col) {
            const directions = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
            const piece = board[row][col];
            let canCaptureMove = false;

            // 首先检查是否存在吃子机会
            if (piece.classList.contains('king')) {
                // 王棋的吃子检查
                if (mustCapture()) {
                    // 如果必须吃子，只显示可以吃子的位置
                    for (const [dRow, dCol] of directions) {
                        let newRow = row + dRow;
                        let newCol = col + dCol;
                        let foundOpponent = false;
                        
                        while (newRow >= 0 && newRow < 10 && newCol >= 0 && newCol < 10) {
                            if (board[newRow][newCol] !== null) {
                                if (board[newRow][newCol].classList.contains(currentPlayer)) break;
                                if (foundOpponent) break;
                                foundOpponent = true;
                                
                                // 检查对手棋子后的第一个空位
                                const nextRow = newRow + dRow;
                                const nextCol = newCol + dCol;
                                if (nextRow >= 0 && nextRow < 10 && nextCol >= 0 && nextCol < 10 && 
                                    board[nextRow][nextCol] === null) {
                                    const square = document.querySelector(`[data-row='${nextRow}'][data-col='${nextCol}']`);
                                    square.classList.add('highlight');
                                    canCaptureMove = true;
                                }
                                break;
                            }
                            newRow += dRow;
                            newCol += dCol;
                        }
                    }
                } else {
                    // 没有吃子机会时的普通移动
                    for (const [dRow, dCol] of directions) {
                        let newRow = row + dRow;
                        let newCol = col + dCol;
                        let validPath = true;
                        
                        while (validPath && newRow >= 0 && newRow < 10 && newCol >= 0 && newCol < 10) {
                            if (board[newRow][newCol] === null) {
                                // 检查是否是有效的移动
                                if (isValidMove(row, col, newRow, newCol)) {
                                    const square = document.querySelector(`[data-row='${newRow}'][data-col='${newCol}']`);
                                    square.classList.add('highlight');
                                }
                                newRow += dRow;
                                newCol += dCol;
                            } else {
                                validPath = false;
                            }
                        }
                    }
                }
            } else {
                // 普通棋子的移动
            for (const [dRow, dCol] of directions) {
                const middleRow = row + dRow;
                const middleCol = col + dCol;
                const newRow = row + 2 * dRow;
                const newCol = col + 2 * dCol;

                    if (newRow >= 0 && newRow < 10 && newCol >= 0 && newCol < 10) {
                        if (board[middleRow][middleCol] && 
                            !board[middleRow][middleCol].classList.contains(currentPlayer) && 
                            board[newRow][newCol] === null) {
                        const square = document.querySelector(`[data-row='${newRow}'][data-col='${newCol}']`);
                        square.classList.add('highlight');
                        canCaptureMove = true;
                        }
                    }
                }
            }

            // 如果没有吃子机会，才显示普通移动
            if (!canCaptureMove && !mustCapture()) {
                if (piece.classList.contains('king')) {
                    // 王棋的普通移动
                    for (const [dRow, dCol] of directions) {
                        let newRow = row + dRow;
                        let newCol = col + dCol;
                        while (newRow >= 0 && newRow < 10 && newCol >= 0 && newCol < 10 && 
                               board[newRow][newCol] === null) {
                            const square = document.querySelector(`[data-row='${newRow}'][data-col='${newCol}']`);
                            square.classList.add('highlight');
                            newRow += dRow;
                            newCol += dCol;
                        }
                    }
                } else {
                    // 普通棋子的移动
                    const direction = currentPlayer === 'white-piece' ? -1 : 1;
                    for (const [dRow, dCol] of directions) {
                        const newRow = row + direction * dRow;
                        const newCol = col + dCol;
                        if (newRow >= 0 && newRow < 10 && newCol >= 0 && newCol < 10 && 
                            board[newRow][newCol] === null) {
                            if (isValidMove(row, col, newRow, newCol)) {
                                const square = document.querySelector(`[data-row='${newRow}'][data-col='${newCol}']`);
                                square.classList.add('highlight');
                            }
                        }
                    }
                }
            }
        }

        function clearHighlights() {
            const highlightedSquares = document.querySelectorAll('.highlight');
            highlightedSquares.forEach(square => square.classList.remove('highlight'));
        }

        function mustCapture() {
            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 10; col++) {
                    if (board[row][col] && board[row][col].classList.contains(currentPlayer) && canCapture(row, col)) {
                        return true;
                    }
                }
            }
            return false;
        }

        // 添加重新开始游戏的函数
        function restartGame() {
            // 清空棋盘
            boardElement.innerHTML = '';
            board.length = 0;
            
            // 重置游戏状态
            selectedPiece = null;
            currentPlayer = 'white-piece';
            currentPlayerElement.textContent = '白方回合';
            
            // 重新创建棋盘
            createBoard();
        }

        // 修改玩家回合显示的文本
        function updateCurrentPlayerText() {
            currentPlayerElement.textContent = currentPlayer === 'white-piece' ? "白方回合" : "黑方回合";
        }

        function clearBoard() {
            if (confirm('确定要清除所有棋子吗？')) {
                for (let row = 0; row < 10; row++) {
                    for (let col = 0; col < 10; col++) {
                        const square = document.querySelector(`[data-row='${row}'][data-col='${col}']`);
                        if (board[row][col]) {
                            square.innerHTML = '';
                            board[row][col] = null;
                        }
                    }
                }
                selectedPiece = null;
                clearHighlights();
            }
        }

        function toggleTurn() {
            if (editMode) {
                currentPlayer = currentPlayer === 'white-piece' ? 'black-piece' : 'white-piece';
                updateCurrentPlayerText();
            }
        }

        createBoard();
    </script>
</body>
</html>