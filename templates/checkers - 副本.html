<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>国际跳棋</title>
    <style>
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .game-info {
            display: flex;
            gap: 20px;
            align-items: center;
            margin: 20px 0;
        }
        .board {
            display: grid;
            grid-template-columns: repeat(10, 60px);
            grid-template-rows: repeat(10, 60px);
            gap: 0;
            margin-bottom: 20px;
            border: 15px solid #DAA520;
            box-shadow: 
                0 0 15px rgba(0, 0, 0, 0.2),
                inset 0 0 8px rgba(0, 0, 0, 0.3);
            background: #DAA520;
            padding: 3px;
            border-radius: 3px;
        }
        .black, .white {
            width: 60px;
            height: 60px;
            cursor: pointer;
        }
        .black {
            background-color: #2c2c2c;
        }
        .white {
            background-color: #f0f0f0;
        }
        .piece {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            margin: 5px;
            cursor: pointer;
            position: relative;
            transition: transform 0.2s;
        }
        .black-piece {
            background: radial-gradient(circle at 30% 30%, #666, #000);
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.4),
                inset 0 2px 4px rgba(255, 255, 255, 0.3);
        }
        .white-piece {
            background: radial-gradient(circle at 30% 30%, #fff, #ccc);
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.4),
                inset 0 2px 4px rgba(255, 255, 255, 0.8);
        }
        .piece:hover {
            transform: scale(1.05);
        }
        .king {
            border: 3px solid gold;
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.4),
                inset 0 2px 4px rgba(255, 255, 255, 0.3),
                0 0 10px gold;
        }
        .highlight {
            background-color: #32CD32 !important;
            box-shadow: inset 0 0 15px rgba(255, 255, 255, 0.4);
        }
        .current-player {
            padding: 12px 24px;
            border: 2px solid #333;
            width: 120px;
            text-align: center;
            border-radius: 5px;
            background: #fff;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            cursor: pointer;
        }
        .current-player:hover {
            background: #f5f5f5;
        }
        .restart-button, .edit-mode-button {
            padding: 12px 24px;
            font-size: 16px;
            background: linear-gradient(145deg, #2c2c2c, #1a1a1a);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        .restart-button:hover, .edit-mode-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .edit-mode-button.active {
            background: linear-gradient(145deg, #4CAF50, #45a049);
        }
        
        .edit-options {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            display: none;
            z-index: 1000;
        }
        
        .edit-options button {
            display: block;
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            border: none;
            border-radius: 4px;
            background: #4CAF50;
            color: white;
            cursor: pointer;
        }
        
        .edit-options button:hover {
            background: #45a049;
        }

        .clear-board-button {
            padding: 12px 24px;
            font-size: 16px;
            background: linear-gradient(145deg, #ff4444, #cc0000);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            margin-left: 10px;
        }
        
        .clear-board-button:hover {
            background: linear-gradient(145deg, #cc0000, #ff4444);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>国际跳棋</h1>
        <div class="game-info">
            <div class="current-player" id="currentPlayer" onclick="toggleTurn()">白方回合</div>
            <button class="restart-button" onclick="restartGame()">重新开始</button>
            <button class="edit-mode-button" onclick="toggleEditMode()">普通模式</button>
            <button class="clear-board-button" onclick="clearBoard()">清除棋子</button>
        </div>
        <div class="board" id="board"></div>
        
        <!-- 添加编辑选项对话框 -->
        <div id="editOptions" class="edit-options">
            <button onclick="setSquareProperty(selectedRow, selectedCol, '空格')">空格</button>
            <button onclick="setSquareProperty(selectedRow, selectedCol, '黑棋')">黑棋</button>
            <button onclick="setSquareProperty(selectedRow, selectedCol, '黑王')">黑王</button>
            <button onclick="setSquareProperty(selectedRow, selectedCol, '白棋')">白棋</button>
            <button onclick="setSquareProperty(selectedRow, selectedCol, '白王')">白王</button>
            <button onclick="hideEditOptions()">取消</button>
        </div>
    </div>

    <script>
        const boardElement = document.getElementById('board');
        const currentPlayerElement = document.getElementById('currentPlayer');
        const board = [];
        let selectedPiece = null;
        let currentPlayer = 'white-piece';
        let editMode = false;
        let selectedRow, selectedCol;
        const editOptionsElement = document.getElementById('editOptions');

        function createBoard() {
            for (let row = 0; row < 10; row++) {
                board[row] = [];
                for (let col = 0; col < 10; col++) {
                    const square = document.createElement('div');
                    square.className = (row + col) % 2 === 0 ? 'black' : 'white';
                    square.dataset.row = row;
                    square.dataset.col = col;
                    square.addEventListener('click', () => selectSquare(row, col));
                    boardElement.appendChild(square);
                    board[row][col] = null;

                    if (square.className === 'black') {
                        if (row < 4) {
                            const piece = createPiece('black-piece');
                            square.appendChild(piece);
                            board[row][col] = piece;
                        } else if (row > 5) {
                            const piece = createPiece('white-piece');
                            square.appendChild(piece);
                            board[row][col] = piece;
                        }
                    }
                }
            }
            console.log("Board created");
        }

        function createPiece(color) {
            const piece = document.createElement('div');
            piece.className = `piece ${color}`;
            return piece;
        }

        function selectSquare(row, col) {
            if (editMode) {
                showEditOptions(row, col);
            } else {
                clearHighlights();
                if (selectedPiece) {
                    console.log(`Attempting to move piece from (${selectedPiece.row}, ${selectedPiece.col}) to (${row}, ${col})`);
                    movePiece(row, col);
                } else if (board[row][col] && board[row][col].classList.contains(currentPlayer)) {
                    if (mustCapture() && !canCapture(row, col)) {
                        console.log(`Must capture, cannot select piece at (${row}, ${col})`);
                        return;
                    }
                    selectedPiece = { piece: board[row][col], row, col };
                    highlightMoves(row, col);
                    console.log(`Selected piece at (${row}, ${col})`);
                } else {
                    console.log(`Invalid selection at (${row}, ${col})`);
                }
            }
        }

        function showEditOptions(row, col) {
            selectedRow = row;
            selectedCol = col;
            editOptionsElement.style.display = 'block';
        }

        function hideEditOptions() {
            editOptionsElement.style.display = 'none';
        }

        function setCurrentPlayer(player) {
            currentPlayer = player;
            updateCurrentPlayerText();
            hideEditOptions();
        }

        function setSquareProperty(row, col, property) {
            const square = document.querySelector(`[data-row='${row}'][data-col='${col}']`);
            square.innerHTML = '';
            board[row][col] = null;

            switch (property) {
                case '白棋':
                    const whitePiece = createPiece('white-piece');
                    square.appendChild(whitePiece);
                    board[row][col] = whitePiece;
                    break;
                case '黑棋':
                    const blackPiece = createPiece('black-piece');
                    square.appendChild(blackPiece);
                    board[row][col] = blackPiece;
                    break;
                case '白王':
                    const whiteKing = createPiece('white-piece');
                    whiteKing.classList.add('king');
                    square.appendChild(whiteKing);
                    board[row][col] = whiteKing;
                    break;
                case '黑王':
                    const blackKing = createPiece('black-piece');
                    blackKing.classList.add('king');
                    square.appendChild(blackKing);
                    board[row][col] = blackKing;
                    break;
                case '空格':
                default:
                    break;
            }
            hideEditOptions();
        }

        function toggleEditMode() {
            editMode = !editMode;
            const editButton = document.querySelector('.edit-mode-button');
            
            if (editMode) {
                editButton.classList.add('active');
                editButton.textContent = '编辑模式';
                editButton.style.background = 'linear-gradient(145deg, #4CAF50, #45a049)';
            } else {
                editButton.classList.remove('active');
                editButton.textContent = '普通模式';
                editButton.style.background = 'linear-gradient(145deg, #2c2c2c, #1a1a1a)';
            }
            
            // 清除选中状态和高亮
            selectedPiece = null;
            clearHighlights();
            hideEditOptions();
        }

        function movePiece(row, col) {
            const { piece, row: oldRow, col: oldCol } = selectedPiece;

            if (isValidMove(oldRow, oldCol, row, col)) {
                board[oldRow][oldCol] = null;
                board[row][col] = piece;
                const square = document.querySelector(`[data-row='${row}'][data-col='${col}']`);
                square.appendChild(piece);
                selectedPiece = null;
                console.log(`Moved piece to (${row}, ${col})`);

                // Check for king promotion
                if ((currentPlayer === 'white-piece' && row === 0) || (currentPlayer === 'black-piece' && row === 9)) {
                    piece.classList.add('king');
                    console.log(`Piece at (${row}, ${col}) promoted to king`);
                }

                // Check if another capture is possible
                if (Math.abs(row - oldRow) === 2 && canCapture(row, col)) {
                    selectedPiece = { piece, row, col };
                    highlightMoves(row, col);
                } else {
                    // Switch player if no more captures
                    currentPlayer = currentPlayer === 'white-piece' ? 'black-piece' : 'white-piece';
                    updateCurrentPlayerText();
                    console.log(`Switched to ${currentPlayer}`);
                }
            } else {
                console.log(`Invalid move from (${oldRow}, ${oldCol}) to (${row}, ${col})`);
                selectedPiece = null; // Reset selection if move is invalid
            }
        }

        function isValidMove(oldRow, oldCol, newRow, newCol) {
            console.log(`Checking move from (${oldRow}, ${oldCol}) to (${newRow}, ${newCol})`);
            const rowDiff = newRow - oldRow;
            const colDiff = newCol - oldCol;

            if (board[newRow][newCol] !== null) {
                console.log('Target square is occupied');
                return false;
            }

            if (board[oldRow][oldCol].classList.contains('king')) {
                console.log('Moving a king piece');
                // 检查是否有吃子机会
                if (mustCapture()) {
                    // 在有吃子机会时，必须执行吃子移动
                    let isValidCapture = false;
                    let foundOpponent = false;
                    const stepRow = rowDiff / Math.abs(rowDiff);
                    const stepCol = colDiff / Math.abs(colDiff);
                    
                    // 检查路径上是否有且仅有一个对手的棋子
                    for (let i = 1; i < Math.abs(rowDiff); i++) {
                        const currentRow = oldRow + i * stepRow;
                        const currentCol = oldCol + i * stepCol;
                        if (board[currentRow][currentCol] !== null) {
                            if (foundOpponent || board[currentRow][currentCol].classList.contains(currentPlayer)) {
                                return false;
                            }
                            foundOpponent = true;
                        }
                    }
                    
                    // 必须是吃子移动
                    if (!foundOpponent) {
                        console.log('Must capture when possible');
                        return false;
                    }

                    // 执行吃子移动
                    for (let i = 1; i < Math.abs(rowDiff); i++) {
                        const currentRow = oldRow + i * stepRow;
                        const currentCol = oldCol + i * stepCol;
                        if (board[currentRow][currentCol] !== null) {
                            console.log(`Capturing piece at (${currentRow}, ${currentCol})`);
                            board[currentRow][currentCol].remove();
                            board[currentRow][currentCol] = null;
                            break;
                        }
                    }
                    return true;
                } else {
                    // 没有吃子机会时的普通移动
                    if (Math.abs(rowDiff) === Math.abs(colDiff)) {
                        const stepRow = rowDiff / Math.abs(rowDiff);
                        const stepCol = colDiff / Math.abs(colDiff);
                        
                        // 检查路径上是否有棋子
                        for (let i = 1; i < Math.abs(rowDiff); i++) {
                            const currentRow = oldRow + i * stepRow;
                            const currentCol = oldCol + i * stepCol;
                            if (board[currentRow][currentCol] !== null) {
                                return false;
                            }
                        }
                        return true;
                    }
                }
            } else {
                // 普通棋子的移动逻辑保持不变
                const direction = currentPlayer === 'white-piece' ? -1 : 1;
                
                if (mustCapture()) {
                    // 在有吃子机会时，必须执行吃子移动
                    if (Math.abs(rowDiff) === 2 && Math.abs(colDiff) === 2) {
                        const middleRow = (oldRow + newRow) / 2;
                        const middleCol = (oldCol + newCol) / 2;
                        if (board[middleRow][middleCol] && 
                            !board[middleRow][middleCol].classList.contains(currentPlayer)) {
                            board[middleRow][middleCol].remove();
                            board[middleRow][middleCol] = null;
                            return true;
                        }
                    }
                    return false;
                } else {
                    // 没有吃子机会时的普通移动
                    if (rowDiff === direction && Math.abs(colDiff) === 1) {
                        return true;
                    }
                }
            }

            console.log('Move is invalid');
            return false;
        }

        function canCapture(row, col) {
            console.log(`Checking capture possibilities for piece at (${row}, ${col})`);
            const directions = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
            const piece = board[row][col];
            
            if (piece.classList.contains('king')) {
                for (const [dRow, dCol] of directions) {
                    let newRow = row + dRow;
                    let newCol = col + dCol;
                    let foundOpponent = false;
                    
                    while (newRow >= 0 && newRow < 10 && newCol >= 0 && newCol < 10) {
                        if (board[newRow][newCol] !== null) {
                            if (board[newRow][newCol].classList.contains(currentPlayer)) break;
                            if (foundOpponent) break;
                            foundOpponent = true;
                            
                            const nextRow = newRow + dRow;
                            const nextCol = newCol + dCol;
                            if (nextRow >= 0 && nextRow < 10 && nextCol >= 0 && nextCol < 10 && 
                                board[nextRow][nextCol] === null) {
                                console.log(`King can capture from (${row}, ${col}) to (${nextRow}, ${nextCol})`);
                                return true;
                            }
                        }
                        newRow += dRow;
                        newCol += dCol;
                    }
                }
            } else {
                for (const [dRow, dCol] of directions) {
                    const newRow = row + 2 * dRow;
                    const newCol = col + 2 * dCol;
                    const middleRow = row + dRow;
                    const middleCol = col + dCol;
                    
                    if (newRow >= 0 && newRow < 10 && newCol >= 0 && newCol < 10 && 
                        board[middleRow][middleCol] && 
                        !board[middleRow][middleCol].classList.contains(currentPlayer) && 
                        board[newRow][newCol] === null) {
                        console.log(`Regular piece can capture from (${row}, ${col}) to (${newRow}, ${newCol})`);
                        return true;
                    }
                }
            }
            
            console.log(`No capture possible for piece at (${row}, ${col})`);
            return false;
        }

        function highlightMoves(row, col) {
            const directions = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
            const piece = board[row][col];
            let canCaptureMove = false;

            // 首先检查是否存在吃子机会
            if (piece.classList.contains('king')) {
                // 王棋的吃子检查
                for (const [dRow, dCol] of directions) {
                    let newRow = row + dRow;
                    let newCol = col + dCol;
                    let foundOpponent = false;
                    
                    while (newRow >= 0 && newRow < 10 && newCol >= 0 && newCol < 10) {
                        if (board[newRow][newCol] !== null) {
                            if (board[newRow][newCol].classList.contains(currentPlayer)) break;
                            if (foundOpponent) break;
                            foundOpponent = true;
                            
                            // 检查对手棋子后的空位
                            let nextRow = newRow + dRow;
                            let nextCol = newCol + dCol;
                            while (nextRow >= 0 && nextRow < 10 && nextCol >= 0 && nextCol < 10 && 
                                   board[nextRow][nextCol] === null) {
                                const square = document.querySelector(`[data-row='${nextRow}'][data-col='${nextCol}']`);
                                square.classList.add('highlight');
                                canCaptureMove = true;
                                nextRow += dRow;
                                nextCol += dCol;
                            }
                            break;
                        }
                        newRow += dRow;
                        newCol += dCol;
                    }
                }
            } else {
                // 普通棋子的吃子检查
                for (const [dRow, dCol] of directions) {
                    const middleRow = row + dRow;
                    const middleCol = col + dCol;
                    const newRow = row + 2 * dRow;
                    const newCol = col + 2 * dCol;

                    if (newRow >= 0 && newRow < 10 && newCol >= 0 && newCol < 10) {
                        if (board[middleRow][middleCol] && 
                            !board[middleRow][middleCol].classList.contains(currentPlayer) && 
                            board[newRow][newCol] === null) {
                            const square = document.querySelector(`[data-row='${newRow}'][data-col='${newCol}']`);
                            square.classList.add('highlight');
                            canCaptureMove = true;
                        }
                    }
                }
            }

            // 如果没有吃子机会，才显示普通移动
            if (!canCaptureMove && !mustCapture()) {
                if (piece.classList.contains('king')) {
                    // 王棋的普通移动
                    for (const [dRow, dCol] of directions) {
                        let newRow = row + dRow;
                        let newCol = col + dCol;
                        while (newRow >= 0 && newRow < 10 && newCol >= 0 && newCol < 10 && 
                               board[newRow][newCol] === null) {
                            const square = document.querySelector(`[data-row='${newRow}'][data-col='${newCol}']`);
                            square.classList.add('highlight');
                            newRow += dRow;
                            newCol += dCol;
                        }
                    }
                } else {
                    // 普通棋子的移动
                    const direction = currentPlayer === 'white-piece' ? -1 : 1;
                    for (const [dRow, dCol] of directions) {
                        const newRow = row + direction * dRow;
                        const newCol = col + dCol;
                        if (newRow >= 0 && newRow < 10 && newCol >= 0 && newCol < 10 && 
                            board[newRow][newCol] === null) {
                            if (isValidMove(row, col, newRow, newCol)) {
                                const square = document.querySelector(`[data-row='${newRow}'][data-col='${newCol}']`);
                                square.classList.add('highlight');
                            }
                        }
                    }
                }
            }
        }

        function clearHighlights() {
            const highlightedSquares = document.querySelectorAll('.highlight');
            highlightedSquares.forEach(square => square.classList.remove('highlight'));
        }

        function mustCapture() {
            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 10; col++) {
                    if (board[row][col] && board[row][col].classList.contains(currentPlayer) && canCapture(row, col)) {
                        return true;
                    }
                }
            }
            return false;
        }

        // 添加重新开始游戏的函数
        function restartGame() {
            // 清空棋盘
            boardElement.innerHTML = '';
            board.length = 0;
            
            // 重置游戏状态
            selectedPiece = null;
            currentPlayer = 'white-piece';
            currentPlayerElement.textContent = '白方回合';
            
            // 重新创建棋盘
            createBoard();
        }

        // 修改玩家回合显示的文本
        function updateCurrentPlayerText() {
            currentPlayerElement.textContent = currentPlayer === 'white-piece' ? "白方回合" : "黑方回合";
        }

        function clearBoard() {
            if (confirm('确定要清除所有棋子吗？')) {
                for (let row = 0; row < 10; row++) {
                    for (let col = 0; col < 10; col++) {
                        const square = document.querySelector(`[data-row='${row}'][data-col='${col}']`);
                        if (board[row][col]) {
                            square.innerHTML = '';
                            board[row][col] = null;
                        }
                    }
                }
                selectedPiece = null;
                clearHighlights();
            }
        }

        function toggleTurn() {
            if (editMode) {
                currentPlayer = currentPlayer === 'white-piece' ? 'black-piece' : 'white-piece';
                updateCurrentPlayerText();
            }
        }

        createBoard();
    </script>
</body>
</html>